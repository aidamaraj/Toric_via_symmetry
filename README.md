# Toric via symmetry
This repository hosts the codes and and necessary computational results supporting the preprint Symmetry Lie Algebras of Varieties with Applications to Algebraic Statistics, which can be found on arXiv: https://arxiv.org/abs/2309.10741. 

SageMath version 10.3, Release Date: 2024-03-19                    â”‚
Using Python 3.11.8.     

The implimentation of the key algorithm in the paper (Theorem 2) can be found in the file `Symmalg.sage`. Examples of the how to use the code are in `Test_notebook.ipynb` and `Toricideal.ipynb`.

In `ToricIdeal_9x9_conjecture_disproved.ipynb`, we compute the symmetry Lie algebra for the vanishing ideal $I$ of the caterpilar tree in one stage of depth and degree 3 in Figure 2 in the paper. This Lie algebra has dimension 2, while the ideal itself has dimension 3. By Theorem 1 in the paper, there is no linear chnge of variables that turns $I$ into a toric ideal. This is the smallest and first **non-toric** one stage tree model.

## Documentation (descriptions of the functions)

`symmalg(generators, n = 0)` 
this is our main function, implemented in `Symmalg.sage`. The input is a set of polynomials in a polynomial ring specified earlier.  It returns the Lie algebra of the ideal generated by these polynomials (GAP Lie object) and it prints out a basis for it. 

    
`rank_poly(M)` 
this function takes a matrix "M" with polynomial entries as input, substitutes random values for the variables, and then returns the rank of the matrix.


### Example 1

To compute the symmetry Lie algebra of the ideal generated by $x^2+y^2+z^2$ we do:

```
load('Symmalg.sage')
R = PolynomialRing(QQ,['x', 'y','z']) # initiate the ring
R.inject_variables()  # inject the variables
LieI = symmalg([x^2+y^2+z^2],3) # call the function 
```

If we would like to display computation time, we substitute the last line by:
```
import time
start_time = time.time()
LieI = symmalg([x^2+y^2+z^2],3)
end_time = time.time()
comp_time = end_time - start_time # Compute the elapsed time
minutes = int(comp_time // 60)
seconds = comp_time % 60
formatted_time_str = f"{minutes} min {seconds:.2f} sec"
print(f"\nComputation Time: {formatted_time_str}")
```

