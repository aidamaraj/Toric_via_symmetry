def rank_poly(M):
    '''
    This function takes a matrix "M" with polynomial entries as input,
    and substitutes random values for the variables and then computes the rank of the matrix.
    Then this function returns the found rank.
    '''
    R=M.base_ring()
    D={}
    for i in range(len(R.gens())):
        D[R.gens()[i]]=QQ.random_element(num_bound=10^3,den_bound=10^3)
    rank1=M.subs(D).rank()

    D={}
    for i in range(len(R.gens())):
        D[R.gens()[i]]=QQ.random_element(num_bound=10^3,den_bound=10^3)
    rank2=M.subs(D).rank()

    return max(rank1,rank2)

def monomial_generator(variables, degree):
    '''
    This function takes a set of variables and a degree as input and 
returns a list of monomials of desired degree in the given set 
of variables.
    '''
    n_vars = len(variables)
    degs = list(WeightedIntegerVectors(degree,[1 for i in range(n_vars)]))
    monomials = []
    for d in degs:
        mon = 1
        for i in range(n_vars):
            mon *= variables[i]^d[i]
        monomials.append(mon)
    return monomials

def lie_derivative_mono(monomial, g, n = 0):
    '''
    This function takes a monomial and a matrix `g` as input and returns Lie derivative of the monomial with respect to `g`.
    monomial = a monomial
    g = a matrix, with respect to which the Lie derivative is calculated
    n = number of variables in the ambient ring, optional argument
    '''
    if n == 0:
        n_vars = len(monomial.parent().gens())
    else:
        n_vars = n
    R = monomial.parent()
    X = matrix(R,n_vars, 1, R.gens()[:n_vars])
    gen_index = {}
    for l in range(len(R.gens())):
        gen_index[R.gens()[l]] = l
    der = 0
    for x in monomial.factor():
        l = (g[gen_index[x[0]],:]*X)[0,0]
        der+= l*R(monomial/x[0])*x[1]
    return der

def lie_derivative_poly(poly, g, n = 0):
    '''
    This function takes a polynomial and a matrix `g` as input, and returns Lie derivative of the polynomial with respect to `g`.
    polynomial = a polynomial
    g = a matrix, with respect to which the Lie derivative is calculated
    n = number of variables in the ambient ring, optional argument
    '''
    if n == 0:
        n_vars = len(poly.parent().gens())
    else:
        n_vars = n
    der = 0
    for mon, coef in list(zip(poly.monomials(),poly.coefficients())):
        der+= lie_derivative_mono(mon,g, n_vars)*coef
    return der

def poly_to_vec(polynomial, n = 0, degree = 0):
    '''
    This function takes a polynomial as input and returns its vector representation as output.
    polynomial = a polynomial
    n = number of variables in the ambient polynomial ring
    degree = degree of the polynomial
    '''
    R = polynomial.parent()
    if n == 0:
        n_vars = len(R.gens())
    else:
        n_vars = n
    if degree == 0:
        d = polynomial.degree()
    else:
        d = degree
    n_2 = binomial(n_vars+d-1,d)
    monomials = monomial_generator(R.gens()[:n_vars], d)
    vec = [0 for j in range(n_2)]
    for i in range(n_2):
        vec[i] = polynomial.coefficient(monomials[i])
    return vec

def symmalg_homo(generators, n = 0):
    ''' 
    This function takes generators of a homogeneous prime ideal as input.
    Then computes and returns the symmetry Lie algebra of the ideal generated by the polynomials in `generatos`. 
    This function also assumes that all the generating polynomials of the ideal homogeneous and of same degree.
    generatots = generators of the ideal
    n = number of variables in the ambient ring
    '''
    S = generators[0].parent()
    if n!=0:
        n_vars = n
    else:
        n_vars = len(S.gens())
    var =[str(t) for t in S.gens()[:n_vars]]
    var+= ['g%i%i'%(i,j) for i in range(1,n_vars+1) for j in range(1,n_vars+1)]
    R = PolynomialRing(QQ, var)
    R.inject_variables()
    gens = [R(g) for g in generators]
    d = gens[0].degree()
    g = matrix(R,n_vars,n_vars,R.gens()[n_vars:])
    gens_vecs = [poly_to_vec(gen, n_vars) for gen in gens]
    der_gens_vecs = [poly_to_vec(lie_derivative_poly(gen, g, n_vars), n_vars, d) for gen in gens]
    matrices = [matrix(gens_vecs+[i]) for i in der_gens_vecs]
    eqns = set()
    for M in matrices:
        for eqn in M.minors(len(gens)+1):
            if eqn!= 0:
                eqns.add(eqn)
    eqns = list(eqns)
    ker = []
    for eqn in eqns:
        l = [eqn.coefficient(gij) for gij in R.gens()[n_vars:]]
        ker.append(l)
    K = matrix(ker)
    rows = K.pivot_rows()
    K = K[rows,:]
    K_ker = K.right_kernel_matrix()
    L = [matrix(QQ,n_vars,n_vars,r) for r in K_ker.rows()]
    LieI = gap.LieAlgebra(gap.Rationals,L)
    print('\nA basis of the Lie algebra consists of the following matrices:\n')
    show(L)
    return LieI


def symmalg(generators, n = 0):
    ''' 
    This function takes generators of a homogeneous prime ideal as input.
    Then computes and returns the symmetry Lie algebra of the ideal generated by the polynomials in `generatos`.
    generatots = generators of the ideal, a list
    n = number of variables in the ambient ring
    '''
    S = generators[0].parent()
    if n!=0:
        n_vars = n
    else:
        n_vars = len(S.gens())
    var =[str(t) for t in S.gens()[:n_vars]]
    R = PolynomialRing(QQ, var)
    R.inject_variables()
    gens = [R(g) for g in generators]
    d = max([g.degree() for g in gens])
    L = []
    for g in gens:
        monomials = monomial_generator(R.gens()[:n_vars], d-g.degree())
        for m in monomials:
            L.append(g*m)
    M = matrix(R, [poly_to_vec(l, n_vars, d) for l in L])
    rows = M.pivot_rows()
    LieI = symmalg_homo([L[i] for i in rows],n_vars)
    return LieI


def find_eqn(M, eqns_dic, vals, length = 1):
    '''
    Inputs:
    M = A matrix with variable entries
    eqns_dic = A dictionary consisting of already found equations
    vals = A dictionary consisting of values corresponding to variables of the ambient ring
    length = Length of desired equation. i.e., number of monomials in the desired equation, a positive integer less than or equal to 3
    Outputs:
    eqns_dic  = Returns a copy of the dictionary eqns_dic
    True/False = Returns True, if new equation have added to eqns_dic. Returns False otherwise.

    This function takes the matrix "M", and "length" as inputs, and looks for an equation, a maximal minor, 
    having no more than "length" monomials.
    Once it finds such an equation it asks the user whether they'd like to accept that equation or not.
    If prompted yes, it adds that equation to the "eqns_dic" dictionary and returns.
    If prompted no, it asks if the user would like to enter the equation themselves.
    '''
    M_sub = M.subs(vals)
    ncols = M.ncols()
    for i in range(100):
        p = Permutations(ncols).random_element()
        M_sub.permute_columns(p)
        cols = M_sub.pivots()
        M.permute_columns(p)
        eqn = M[:, cols].det()
        if len(eqn.monomials()) <= length:
            try:
                show(eqn)
            except:
                print(eqn)
            response = input("Would you like to accept this equation? ([Y]/N): ")
            while len(response) == 0:
                response = input("Would you like to accept this equation? ([Y]/N): ")
            if length == 1:
                if response.lower()[0] == 'n':
                    print("If you'd like to search in a different matrix then enter: 'change'")
                    response = input('Would you like to input the polynomial yourself? (Y/[N]):')
                    if response.lower()[0] == 'y':
                        raw_input = input("Enter the polynomial:")
                        try:
                            eqn = R(raw_input)
                            eqns_dic[eqn.monomials()[0]] = 0
                            for i in eqns_dic.keys():
                                eqns_dic[i] = eqns_dic[i].subs(eqns_dic)
                        except Exception as e:
                            raise InvalidInput("Invalid polynomial input.") from e
                        return eqns_dic, True
                    elif response.lower() == 'change':
                        print("Going to work with another matrix.")
                        return eqns_dic, False
                    else:
                        continue
                else:
                    eqns_dic[eqn.monomials()[0]] = 0
                    for i in eqns_dic.keys():
                        eqns_dic[i] = eqns_dic[i].subs(eqns_dic)
                    return eqns_dic, True
            elif length == 2:
                if response.lower()[0] == 'n':
                    print("If you'd like to search in a different matrix then enter: 'change'")
                    response = input('Would you like to input the polynomial yourself? (Y/[N]):')
                    if response.lower()[0] == 'y':
                        raw_input = input("Enter the polynomial:")
                        try:
                            eqn = R(raw_input)
                            mono = eqn.monomials()
                            coef = eqn.coefficients()
                            eqns_dic[mono[0]] = -coef[1]*mono[1]/coef[0]
                            for i in eqns_dic.keys():
                                eqns_dic[i] = eqns_dic[i].subs(eqns_dic)
                        except Exception as e:
                            raise InvalidInput("Invalid polynomial input.") from e
                        return eqns_dic, True
                    elif response.lower() == 'change':
                        print("Going to work with another matrix.")
                        return eqns_dic, False
                    else:
                        continue
                else:
                    mono = eqn.monomials()
                    coef = eqn.coefficients()
                    eqns_dic[mono[0]] = -coef[1]*mono[1]/coef[0]
                    for i in eqns_dic.keys():
                        eqns_dic[i] = eqns_dic[i].subs(eqns_dic)
                    return eqns_dic, True
            elif length == 3:
                if response.lower()[0] == 'n':
                    print("If you'd like to search in a different matrix then enter: 'change'")
                    response = input('Would you like to input the polynomial yourself? (Y/[N]):')
                    if response.lower()[0] == 'y':
                        raw_input = input("Enter the polynomial:")
                        try:
                            eqn = R(raw_input)
                            mono = eqn.monomials()
                            coef = eqn.coefficients()
                            eqns_dic[mono[0]] = -(coef[1]*mono[1] + coef[2]*mono[2])/coef[0]
                            for i in eqns_dic.keys():
                                eqns_dic[i] = eqns_dic[i].subs(eqns_dic)
                        except Exception as e:
                            raise InvalidInput("Invalid polynomial input.") from e
                        return eqns_dic, True
                    elif response.lower() == 'change':
                        print("Going to work with another matrix.")
                        return eqns_dic, False
                    else:
                        continue
                else:
                    mono = eqn.monomials()
                    coef = eqn.coefficients()
                    eqns_dic[mono[0]] = -(coef[1]*mono[1] + coef[2]*mono[2])/coef[0]
                    for i in eqns_dic.keys():
                        eqns_dic[i] = eqns_dic[i].subs(eqns_dic)
                    return eqns_dic, True
        else:
            continue
    print("No equation found of desired length.")
    return eqns_dic, False

def build_equations(eqns_dic, matrices_1, vals):
    '''
    Inputs:
    eqns_dic = A dictionary consisting of already found equations
    matrices_1 = a list of matrices with variable entries
    vals = A dictionary consisting of values corresponding to variables of the ambient ring
    Outputs:
    eqns_dic  = Returns a copy of the dictionary eqns_dic

    This function takes a list, "matrices_1", consisting of matrices with variable entries.
    Then it prompts the user to input the length parameter.
    Then it passes each matrix from the "matrices_1" list to the "find_eqn" function and tries to find an equation of given length.
    '''
    exhausted = False
    while not exhausted:
        #print("Working with matrix %i"%(matrices_1.index(M)+1))
        try:
            length = int(input("Input the lenght parameter (an integer between 0 and 4):"))
        except:
            print("Invalid input.\nReassigning length to 1.")
            length = 1
        for mat in matrices_1:
            M = mat.subs(eqns_dic)
            if rank_poly(M) < 19:
                print('Matrix %i is satisfied. Moving on to the next matrix.' %(matrices_1.index(mat)+1))
                continue
            else:
                print("Working with matrix %i"%(matrices_1.index(mat)+1))
                #M = M.subs(eqns_dic)
                if (0 < length) and (length < 4):
                    length = length
                else:
                    print("You did not enter a value between (excluding) 0 and 4.\nReassigning length to 1.")
                    length = 1
                eqns_dic, changed = find_eqn(M, length=length, eqns_dic = eqns_dic, vals = vals)
                if changed:
                    try:
                        print("eqns_dic = ")
                        show(eqns_dic)
                        break
                    except:
                        print("eqns_dic = ", eqns_dic)
                        break
        for mat in matrices_1:
            M = mat.subs(eqns_dic)
            exhausted = True
            if rank_poly(M) > 18:
                exhausted = False
                break
    return eqns_dic

